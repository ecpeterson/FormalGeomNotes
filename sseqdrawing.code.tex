%%
%% Package: spectralsequences v1.2.0
%% Author: Hood Chatham
%% Email: hood@mit.edu
%% Date: 2017-12-10
%% License: Latex Project Public License
%%
%% File: sseqdrawing.code.tex
%%
%%    Defines the macros that draw the features of the spectral sequence (at least, those that aren't drawn by tikz).
%%    Everything here has to be super optimized, because like 90% of the execution time is in these functions.
%%    In particular, tikz is a horrible performance hole that must be avoided at all costs. For example, the code
%%    the code to produce the axis ticks used to use the tikz \node command, and in the file example_KF3n.tex drawing
%%    the axes ticks was taking about 1/3 of the compile time (a little under 1s out of a 3.2)
%%

% Only for integer valued coordinates...
\def\sseq@qpointxy#1#2{\pgfqpointxy{\numexpr#1+\sseq@xoffset\relax}{\numexpr#2+\sseq@yoffset\relax}}

\def\sseq@transform@xymirror{
    \pgfsetxvec{\pgfqpoint{1cm}{0cm}}
    \pgfsetyvec{\pgfqpoint{0cm}{1cm}}
    \pgftransformcm{0}{1}{1}{0}{\pgfpointxy{\sseq@xoffset*\sseq@xscale }{\sseq@yoffset*\sseq@yscale}} % Reflect x and y axes,
    \pgftransformshift{\pgfpointxy{-\sseq@xoffset*\sseq@yscale}{-\sseq@yoffset*\sseq@xscale}}    % but we need to conjugate by a shift of (xoffset,yoffset)
    \pgfsetyvec{\pgfqpoint{0cm}{\sseq@xscale cm}}
    \pgfsetxvec{\pgfqpoint{\sseq@yscale cm}{0cm}}
}


\def\sseq@setlayoutparameter#1#2{\@xp\let\csname sseq@#1\@xp\endcsname\csname sseq@#1@#2\endcsname}
\def\sseq@setlayoutparameters{
    \sseq@setlayoutparameter{yaxisorigin}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{drawyaxis}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{yaxisstartoffset}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{yaxisendoffset}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{bottomgridpadding}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{topgridpadding}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{bottomclippadding}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{topclippadding}{x\sseq@xaxistype}
    \sseq@setlayoutparameter{xlabelposition}{x\sseq@xaxistype}
%
    \sseq@setlayoutparameter{xaxisorigin}{y\sseq@yaxistype}
    \sseq@setlayoutparameter{drawxaxis}{y\sseq@xaxistype}
    \sseq@setlayoutparameter{xaxisstartoffset}{y\sseq@yaxistype}
    \sseq@setlayoutparameter{xaxisendoffset}{y\sseq@yaxistype}
    \sseq@setlayoutparameter{leftgridpadding}{y\sseq@yaxistype}
    \sseq@setlayoutparameter{rightgridpadding}{y\sseq@yaxistype}
    \sseq@setlayoutparameter{leftclippadding}{y\sseq@yaxistype}
    \sseq@setlayoutparameter{rightclippadding}{y\sseq@yaxistype}
    \sseq@setlayoutparameter{ylabelposition}{y\sseq@xaxistype}
}

% The appropriate one of these is chosen by the "axis type" keys in sseqkeys.

% Used to determine axis and ticks placement
\def\sseq@xaxisorigin@yborder{\sseq@xmin}
\def\sseq@xaxisorigin@yframe{\sseq@xmin}
\def\sseq@xaxisorigin@ycenter{\sseq@xaxisorigin@center@}
\def\sseq@yaxisorigin@xborder{\sseq@ymin}
\def\sseq@yaxisorigin@xframe{\sseq@ymin}
\def\sseq@yaxisorigin@xcenter{\sseq@yaxisorigin@center@}

% Used to determine clipping and grid boundaries
\def\sseq@leftgridpadding@yborder{\dimexpr\sseq@yaxisgap-\sseq@yclip@axisgap\relax}
\def\sseq@rightgridpadding@yborder{\sseq@xaxis@end@extend}
\def\sseq@leftgridpadding@ycenter{\sseq@xaxis@start@extend}
\def\sseq@rightgridpadding@ycenter{\sseq@xaxis@end@extend}
\def\sseq@leftgridpadding@yframe{\dimexpr\sseq@yaxisgap-\sseq@yclip@axisgap\relax}
\def\sseq@rightgridpadding@yframe{5cm} % Just make it big enough to push off the end of the clip
\def\sseq@leftgridpadding@ynone{\sseq@yaxisgap}
\def\sseq@rightgridpadding@ynone{\sseq@yaxisgap}


\def\sseq@bottomgridpadding@xborder{\dimexpr\sseq@xaxisgap-\sseq@xclip@axisgap\relax}
\def\sseq@topgridpadding@xborder{\sseq@yaxis@end@extend}
\def\sseq@bottomgridpadding@xcenter{\sseq@yaxis@start@extend}
\def\sseq@topgridpadding@xcenter{\sseq@yaxis@end@extend}
\def\sseq@bottomgridpadding@xframe{\dimexpr\sseq@xaxisgap-\sseq@xclip@axisgap\relax}
\def\sseq@topgridpadding@xframe{5cm}
\def\sseq@bottomgridpadding@xnone{\sseqxaxisgap}
\def\sseq@topgridpadding@xnone{\sseq@xaxisgap}

\def\sseq@leftclippadding@yborder{\dimexpr-\sseq@yaxisgap+\sseq@yclip@axisgap\relax}
\def\sseq@rightclippadding@yborder{\dimexpr\sseq@xaxis@end@extend+\sseq@clip@padding@right\relax}
\def\sseq@leftclippadding@ycenter{\dimexpr-\sseq@xaxis@start@extend-\sseq@clip@padding@left\relax}
\def\sseq@rightclippadding@ycenter{\dimexpr\sseq@xaxis@end@extend+\sseq@clip@padding@right\relax}
\def\sseq@leftclippadding@yframe{\dimexpr-\sseq@yaxisgap+\sseq@yclip@axisgap\relax}
\def\sseq@rightclippadding@yframe{\dimexpr\sseq@yaxisgap-\sseq@yclip@axisgap\relax}
\def\sseq@leftclippadding@ynone{\dimexpr-\sseq@yaxisgap-\sseq@clip@padding@left\relax}
\def\sseq@rightclippadding@ynone{\dimexpr\sseq@yaxisgap+\sseq@clip@padding@right\relax}

\def\sseq@bottomclippadding@xborder{\dimexpr-\sseq@xaxisgap+\sseq@xclip@axisgap\relax}
\def\sseq@topclippadding@xborder{\dimexpr\sseq@yaxis@end@extend+\sseq@clip@padding@top\relax}
\def\sseq@bottomclippadding@xcenter{\dimexpr-\sseq@yaxis@start@extend-\sseq@clip@padding@bottom\relax}
\def\sseq@topclippadding@xcenter{\dimexpr\sseq@yaxis@end@extend+\sseq@clip@padding@top\relax}
\def\sseq@bottomclippadding@xframe{\dimexpr-\sseq@xaxisgap+\sseq@xclip@axisgap\relax}
\def\sseq@topclippadding@xframe{\dimexpr\sseq@xaxisgap-\sseq@xclip@axisgap\relax}
\def\sseq@bottomclippadding@xnone{\dimexpr-\sseq@xaxisgap-\sseq@clip@padding@bottom\relax}
\def\sseq@topclippadding@xnone{\dimexpr\sseq@xaxisgap+\sseq@clip@padding@top\relax}

% Used to figure out how much further beyond (min -- max) to draw axes
\def\sseq@xaxisstartoffset@yborder{\dimexpr\sseq@xaxis@tail+\sseq@yaxisgap\relax}
\def\sseq@xaxisendoffset@yborder{\sseq@xaxis@end@extend}
\def\sseq@xaxisstartoffset@ycenter{\sseq@xaxis@start@extend}
\def\sseq@xaxisendoffset@ycenter{\sseq@xaxis@end@extend}
\def\sseq@xaxisstartoffset@yframe{\sseq@yaxisgap}
\def\sseq@xaxisendoffset@yframe{\sseq@yaxisgap}

\def\sseq@yaxisstartoffset@xborder{\dimexpr\sseq@yaxis@tail+\sseq@xaxisgap\relax}
\def\sseq@yaxisendoffset@xborder{\sseq@yaxis@end@extend}
\def\sseq@yaxisstartoffset@xcenter{\sseq@yaxis@start@extend}
\def\sseq@yaxisendoffset@xcenter{\sseq@yaxis@end@extend}
\def\sseq@yaxisstartoffset@xframe{\sseq@xaxisgap}
\def\sseq@yaxisendoffset@xframe{\sseq@xaxisgap}

\def\sseq@xlabelposition@xborder{(0,-\sseq@xaxisstartoffset)}
\def\sseq@xlabelposition@xcenter{(-\sseq@yaxisgap,-\sseq@xaxisstartoffset-5pt)}
\def\sseq@xlabelposition@xframe{(0,-\sseq@xaxisgap-\sseq@xlabelgap-10pt)}
\def\sseq@xlabelposition@xnone{(0,0)}

\def\sseq@ylabelposition@yborder{(0,\sseq@yaxisstartoffset)}
\def\sseq@ylabelposition@ycenter{(-\sseq@xaxisgap,\sseq@yaxisstartoffset+5pt)}
\def\sseq@ylabelposition@yframe{(0,\sseq@yaxisgap+\sseq@ylabelgap+10pt)}
\def\sseq@ylabelposition@ynone{(0,0)}
%%%
%%% Draw axes and clip
%%%
\def\sseq@handlexaxis{
    \bgroup
    \sseq@drawxaxis
    \ifsseq@drawxaxisticks
        \sseq@drawxticks
    \fi
    \egroup
}
\def\sseq@handleyaxis{
    \bgroup
    \sseq@drawyaxis
    \ifsseq@drawyaxisticks
        \sseq@drawyticks
    \fi
    \egroup
}

% Draws an x axis. Use with \sseq@transform@xymirror to draw y axis.
% #1 -- horizontal start offset
% #2 -- horizontal end offset
% #3 -- vertical offset
% #4 -- start value
% #5 -- end value
% #6 -- vertical value
\def\sseq@drawaxis@generic#1#2#3#4#5#6{
    \bgroup
    \pgftransformshift{\pgfqpoint{#2}{#3}}
    \pgfpathmoveto{\sseq@qpointxy{#5}{#6}}
    \egroup
%
    \bgroup
    \pgftransformshift{\pgfqpoint{#1}{#3}}
    \pgfpathlineto{\sseq@qpointxy{#4}{#6}}
    \egroup
}

\def\sseq@drawxaxis@ynone{
    \sseq@drawxaxisticksfalse
}
\def\sseq@drawyaxis@xnone{
    \sseq@drawyaxisticksfalse
}

\def\sseq@drawxaxis@yborder{
    \sseq@drawaxis@generic{-\sseq@xaxisstartoffset}{\sseq@xaxisendoffset}{-\sseq@xaxisgap}{\sseq@xmin}{\sseq@xmax}{\sseq@yaxisorigin}
    \pgfusepath{stroke}
}
\let\sseq@drawxaxis@ycenter\sseq@drawxaxis@yborder

\def\sseq@drawxaxis@yframe{
    \sseq@drawaxis@generic{-\sseq@xaxisstartoffset}{\sseq@xaxisendoffset}{-\sseq@xaxisgap}{\sseq@xmin}{\sseq@xmax}{\sseq@ymin}
    \sseq@drawaxis@generic{-\sseq@xaxisstartoffset}{\sseq@xaxisendoffset}{ \sseq@xaxisgap}{\sseq@xmin}{\sseq@xmax}{\sseq@ymax}
    \pgfusepath{stroke}
}
\def\sseq@drawyaxis@xborder{
    \bgroup
    \sseq@transform@xymirror
    \sseq@drawaxis@generic{-\sseq@yaxisstartoffset}{\sseq@yaxisendoffset}{-\sseq@yaxisgap}{\sseq@ymin}{\sseq@ymax}{\sseq@xaxisorigin}
    \pgfusepath{stroke}%
    \egroup
}
\let\sseq@drawyaxis@xcenter\sseq@drawyaxis@xborder
\def\sseq@drawyaxis@xframe{
    \bgroup
    \sseq@transform@xymirror
    \sseq@drawaxis@generic{-\sseq@yaxisstartoffset}{\sseq@yaxisendoffset}{-\sseq@yaxisgap}{\sseq@ymin}{\sseq@ymax}{\sseq@xmin}
    \sseq@drawaxis@generic{-\sseq@yaxisstartoffset}{\sseq@yaxisendoffset}{ \sseq@yaxisgap}{\sseq@ymin}{\sseq@ymax}{\sseq@xmax}
    \pgfusepath{stroke}%
    \egroup
}

\ExplSyntaxOn
\def\sseq@intdivceiling#1#2{%
    \ifnum#1>\z@ % \int_div_truncate:nn rounds towards 0. We want \int_div_ceiling
        \int_div_truncate:nn{#1+#2-1}{#2} % if positive, use ceil(p/q)=floor((p+q-1)/q) for p,q integers
    \else
        \int_div_truncate:nn{#1}{#2} % if we are negative, towards 0 is ceiling
    \fi
}
\def\sseq@intdivfloor#1#2{%
    \ifnum#1<\z@ % \int_div_truncate:nn rounds towards 0. We want \int_div_floor
        \int_div_truncate:nn{#1-#2+1}{#2} % if we are negative, use floor(p/q) = ceil(p-q+1/q) for p,q integers
    \else
        \int_div_truncate:nn{#1}{#2} % if positive, towards 0 is floor
    \fi
}
\ExplSyntaxOff

% #1 -- xmin
% #2 -- xmax
% #3 -- step
% #4 -- offset
% #5 -- ymin
% #6 -- xaxisgap
% #7 -- code
\def\sseq@tickloop@generic#1#2#3#4#5#6#7{
    \sseq@tempcount=\numexpr % min
        \sseq@intdivceiling{#1}{#3} * #3
        -
        \sseq@intdivceiling{#4}{#3} * #3 + #4
    \relax
    \ifnum\sseq@tempcount<#1\relax
        \advance\sseq@tempcount#3\relax
    \fi
    \sseq@tempcountb=\numexpr#2+1\relax % max
    \loop
        \bgroup
        \pgftransformshift{\sseq@qpointxy{\sseq@tempcount}{#5}}%
        \pgftransformshift{\pgfqpoint{0pt}{#6}}
        #7
        \egroup
        \advance\sseq@tempcount#3\relax
    \ifnum\sseq@tempcount<\sseq@tempcountb\repeat
}


\def\sseq@drawxticks{%
    \sseq@tickloop@generic{\sseq@xmin}{\sseq@xmax}{\sseq@xtickstep}{\sseq@xtickstepoffset}{\sseq@yaxisorigin}{-\sseq@xaxisgap}{
        \pgftransformshift{\pgfqpoint{0pt}{-\sseq@xlabelgap}}
        \pgftransformresetnontranslations
        %\@xp\tikzset\@xp{\sseq@xtickstyle}
        %\pgftext{\tikz@options\tikz@textfont\hbox{$\sseq@xtickfn{\the\sseq@tempx}$}}%
        \@xp\node\@xp[\sseq@xtickstyle]{\hbox{$\sseq@xtickfn{\the\sseq@tempcount}$}};
    }
    \ifnum\sseq@xmajortickstep>\z@
        \sseq@tickloop@generic{\sseq@xmin}{\sseq@xmax}{\sseq@xmajortickstep}{\sseq@xtickstepoffset}{\sseq@yaxisorigin}{-\sseq@xaxisgap}{
            \pgfpathmoveto{\pgfpointorigin}
            \pgfpathlineto{\pgfpoint{0}{-0.4*\sseq@xaxisgap}}
        }
    \fi
    \ifnum\sseq@xminortickstep>\z@
        \sseq@tickloop@generic{\sseq@xmin}{\sseq@xmax}{\sseq@xminortickstep}{\sseq@xtickstepoffset}{\sseq@yaxisorigin}{-\sseq@xaxisgap}{
            \pgfpathmoveto{\pgfpointorigin}
            \pgfpathlineto{\pgfpoint{0}{-0.2*\sseq@xaxisgap}}
        }
    \fi
    \pgfusepath{stroke}
}
\def\sseq@drawyticks{%
    \sseq@transform@xymirror
    \sseq@tickloop@generic{\sseq@ymin}{\sseq@ymax}{\sseq@ytickstep}{\sseq@ytickstepoffset}{\sseq@xaxisorigin}{-\sseq@yaxisgap}{
        \pgftransformshift{\pgfqpoint{0pt}{-\sseq@ylabelgap}}
        \pgftransformresetnontranslations
        %\@xp\tikzset\@xp{\sseq@ytickstyle}
        %\pgftext{\tikz@options\tikz@textfont\hbox{$\sseq@ytickfn{\the\sseq@tempx}$}}%
        \@xp\node\@xp[\sseq@ytickstyle]{\hbox{$\sseq@ytickfn{\the\sseq@tempcount}$}};
    }
    \ifnum\sseq@ymajortickstep>\z@
        \sseq@tickloop@generic{\sseq@ymin}{\sseq@ymax}{\sseq@ymajortickstep}{\sseq@ytickstepoffset}{\sseq@xaxisorigin}{-\sseq@yaxisgap}{
            \pgfpathmoveto{\pgfpointorigin}
            \pgfpathlineto{\pgfpoint{0}{-0.4*\sseq@yaxisgap}}
        }
    \fi
    \ifnum\sseq@yminortickstep>\z@
        \sseq@tickloop@generic{\sseq@ymin}{\sseq@ymax}{\sseq@yminortickstep}{\sseq@ytickstepoffset}{\sseq@xaxisorigin}{-\sseq@yaxisgap}{
            \pgfpathmoveto{\pgfpointorigin}
            \pgfpathlineto{\pgfpoint{0}{-0.2*\sseq@yaxisgap}}
        }
    \fi
    \pgfusepath{stroke}
}


\def\sseq@setupclip{
    %\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \ifsseq@clip
        \ifx\sseq@customclip\pgfutil@empty
            \bgroup
            \def\xmin{\pgftransformshift{\pgfqpoint{\sseq@leftclippadding}{0pt}}}
            \def\ymin{\pgftransformshift{\pgfqpoint{0pt}{\sseq@bottomclippadding}}}
            \def\xmax{\pgftransformshift{\pgfqpoint{\sseq@rightclippadding}{0pt}}}
            \def\ymax{\pgftransformshift{\pgfqpoint{0pt}{\sseq@topclippadding}}}
            \bgroup
            \xmin\ymin
            \pgfpathmoveto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
            \egroup
            \bgroup
            \xmin\ymax
            \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
            \egroup
            \bgroup
            \xmax\ymax
            \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
            \egroup
            \bgroup
            \xmax\ymin
            \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
            \egroup
            \egroup
            \pgfpathclose
            \pgfgetpath\sseq@theclippath % This stores the clipping so I can apply it later
            \pgfusepath{discard}% This has to be after the egroup or else the clipping gets screwed up
%
            \bgroup
                \pgfpathmoveto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
                \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
                \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
                \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
                \pgfpathclose
            \egroup
            \pgfgetpath\sseq@therangepath % Only for deciding whether to draw "tricky edges"
            \pgfusepath{discard}
        \else
            \def\sseq@temp{\path[name path=temp]}
            \@xptwo\sseq@temp\@xp\@gobble\sseq@customclip
            \pgfgetpath\sseq@theclippath
            \let\sseq@theclippath\tikz@intersect@path@name@temp
        \fi
    \else
        \let\sseq@theclippath\relax
    \fi
}
\def\sseq@useclip{\ifx\sseq@theclippath\relax\else\pgfsetpath\sseq@theclippath\pgfusepath{clip}\fi}


% sets \pgf@xa and \pgf@ya equal to the coordinates of (1,1), sets \pgf@xb and \pgf@xb equal to (x grid step, y grid step)
\def\sseq@grid@setstepandgridstep{
    \pgf@process{\pgfqpointxy{1}{1}}
    \pgf@xa=\pgf@x
    \pgf@ya=\pgf@y
    \pgf@process{\pgfqpointxy{\sseq@xgridstep}{\sseq@ygridstep}}
    \pgf@xb=\pgf@x
    \pgf@yb=\pgf@y
}

% #1 -- macro to store result in
% #2 -- "x" or "y" as appropriate
% #3 -- length (with units)
% #4 -- fraction of gridstep
% If #2 is x, then it either sets #1 to #3/(x scale) or xgridstep*#4, whichever is smaller
% The output is intended for use with \pgfpointxy.
\def\sseq@grid@atmostgridstep#1#2#3#4{
    \ifdim#3<\dimexpr\csname pgf@#2b\endcsname*#4\relax
        \pgfmathparse{#3/\csname pgf@#2a\endcsname}
        \let#1\pgfmathresult
    \else
        \edef#1{\csname sseq@#2gridstep\endcsname*#4}
    \fi
}

% This grid was a huge pain in the ass to get right...
\def\sseq@grid@chess{
    \bgroup
    \pgfscope
    % Pad on the right and top by either the grid padding, or the remaining piece of the checkerboard before it would start a new square
    % (it looks ugly to have a tiny sliver). Annoyingly, mod returns its result with the same sign as its input, so in order to reduce mod
    % \sseq@xgridstep and get a positive result, we have to do it twice. The 0.5cm*scale here matches the -0.5 in the \pgfpathgrid call.
    \pgfmathsetmacro\sseq@rightpadding{min(
        \sseq@rightgridpadding,
        1cm*  mod(mod(-\sseq@xmax,\sseq@xgridstep)+\sseq@xgridstep,\sseq@xgridstep)+0.5cm*\sseq@xscale-0.05cm
    )}
    \pgfmathsetmacro\sseq@toppadding{min(
        \sseq@topgridpadding,
        1cm * mod(mod(-\sseq@ymax,\sseq@ygridstep)+\sseq@ygridstep,\sseq@ygridstep)+0.5cm*\sseq@yscale-0.02cm
    )}
    % Because of complicated aliasing issues that arise when misusing the \pgfgrid command in this way,
    % it's more convenient to add a clip than to actually stop things in the right place.
    \clip        (\sseq@xmin-\sseq@xoffset,\sseq@ymin-\sseq@yoffset) ++ (-0.48, -0.48)
        rectangle ([shift={(\sseq@rightpadding pt,\sseq@toppadding pt)}]\sseq@xmax,\sseq@ymax);
%
    \sseq@useclip
    \pgfsetcolor{\sseq@gridcolor}
    \pgfsetstrokeopacity{0.3} % We don't set low opacity for the other grids, but this one is visible even if it is very faint.
    \sseq@grid@setstepandgridstep
%
%  Use ifdim with cm to compare real scalars b/c tex is dumb.
    % okay, now we need to be careful in order to avoid overflows. The hack we are using requires that the xvec and the yvec are equal
    % because we can't apply these via lowlevelsynccm. However, xvec and yvec are the things that prevent overflows.
    % What we need to do is set them both equal to the smaller value. Now the scale factor determines the size of the squares,
    % so we mix in the grid steps. We also need to scale the larger scaled coordinate by the ratio of the two scales.
    \ifdim\sseq@xscale cm<\sseq@yscale cm\relax
        % x is smaller so set both x and y vecs to \sseq@xscale cm.
        \pgfsetxvec{\pgfpoint{\sseq@xscale cm}{0cm}}
        \pgfsetyvec{\pgfpoint{0cm}{\sseq@xscale cm}}
        \def\sseq@xadjustscale{\sseq@xgridstep}
        \def\sseq@yadjustscale{\sseq@yscale/\sseq@xscale*\sseq@ygridstep}
        \def\sseq@stepscale{\sseq@xscale}
    \else
        \pgfsetxvec{\pgfpoint{\sseq@yscale cm}{0cm}}
        \pgfsetyvec{\pgfpoint{0cm}{\sseq@yscale cm}}
        \def\sseq@xadjustscale{(\sseq@xscale/\sseq@yscale*\sseq@xgridstep)}
        \def\sseq@yadjustscale{\sseq@ygridstep}
        \def\sseq@stepscale{\sseq@yscale}
    \fi
    \pgftransformxscale{\sseq@xadjustscale}
    \pgftransformyscale{\sseq@yadjustscale}
    % Now we have to put in some ridiculously complicated shift in order to get the bottom corner in the right place.
    % I found this formula mostly by trial and error.
    % The basic idea that we should be making something divisible by twice the grid step (which is the actual period of our grid)
    % is reasonable enough, but what the heck are these other two terms for? I don't know either, thank god it works.
    \pgftransformshift{\pgfpointxy{
            floor((\sseq@xgridstep-1)/2)/\sseq@xgridstep
            + \ifodd\sseq@xgridstep\space 0 \else 0.5/\sseq@xgridstep\fi
            + mod(1+\sseq@xmin/\sseq@xgridstep,2*\sseq@xgridstep)
        }{
            floor((\sseq@ygridstep-1)/2)/\sseq@ygridstep
            + \ifodd\sseq@ygridstep\space 0\else 0.5/\sseq@ygridstep\fi
            + mod(1+\sseq@ymin/\sseq@ygridstep,2*\sseq@ygridstep)
        }
    }
    % We use lowlevelsynccm to make the scale adjust the line width. Normally scaling doesn't affect line width, text size, etc, which is sensible.
    % When you apply \pgflowlevelsynccm, pgf loses track of the coordinate matrix and it gets indiscriminately applied to everything.
    % This is good for us, because we're doing this absurd thing where we make a checkerboard by drawing a really really fat line.
    \pgflowlevelsynccm
    \pgfsetlinewidth{1cm*\sseq@stepscale}
    \pgfsetdash{{1cm*\sseq@stepscale}{1cm*\sseq@stepscale}}{1cm*\sseq@stepscale}
%
    % Naturally some trial and error occurred here too.
    % Note the huge multiples of \sseq@xgridstep I added in -- they probably aren't necessary, but I don't understand what's going on so whatever.
    % The basic idea is that things need to be divisible by twice the grid step. The part I added in the shift above
    % was the remainder when you divide \sseq@xmin by twice the grid step, now we need to add in the multiple of twice the grid step.
    % The -0.5 is ensuring that the checkerboard boundaries lie at half-integer coordinates (I think).
    \pgfpathgrid[stepx= 2cm*\sseq@stepscale,stepy=2cm*\sseq@stepscale]
    { \pgfpointxy
        { -0.5 + \sseq@intdivfloor{\numexpr\sseq@xmin - \sseq@xgridstep\relax}{2*\sseq@xgridstep}*2*\sseq@xgridstep + \sseq@xoffset - 50*\sseq@xgridstep }
        { -0.5 + \sseq@intdivfloor{\numexpr\sseq@ymin - \sseq@ygridstep\relax}{2*\sseq@ygridstep}*2*\sseq@ygridstep + \sseq@yoffset - 50*\sseq@ygridstep}
    }{ \pgfpointxy
        { \sseq@xmax + \sseq@xoffset + 50*\sseq@xgridstep }
        { \sseq@ymax + \sseq@yoffset + 50*\sseq@ygridstep  }
    }
    \pgfusepath{stroke}
    \endpgfscope
    \egroup
}

\def\sseq@grid@crossword{
    \bgroup
    \pgfscope
    \sseq@useclip
    \pgfsetcolor{\sseq@gridcolor}
    \pgfsetlinewidth{\the\sseq@gridstrokethickness}
    \sseq@grid@setstepandgridstep
%
    % We don't want the grid to end with an extra line, so extend it by one half the step distance or
    % \sseq@---gridpadding, whichever is shorter.
    \sseq@grid@atmostgridstep\sseq@xminpadding{x}{\sseq@leftgridpadding}{1/2}
    \sseq@grid@atmostgridstep\sseq@xmaxpadding{x}{\sseq@rightgridpadding}{1/2}
    \sseq@grid@atmostgridstep\sseq@yminpadding{y}{\sseq@bottomgridpadding}{1/2}
    \sseq@grid@atmostgridstep\sseq@ymaxpadding{y}{\sseq@topgridpadding}{1/2}
%
    \pgftransformshift{\pgfpointxy{-\sseq@xgridstep/2}{-\sseq@ygridstep/2}}
    \pgfpathgrid[stepx=\pgf@xb,stepy=\pgf@yb]
    { \pgfpointxy
        { \sseq@xmin - \sseq@xminpadding + 0.01 + \sseq@xoffset + \sseq@xgridstep/2 }
        { \sseq@ymin - \sseq@yminpadding + 0.01 + \sseq@yoffset + \sseq@ygridstep/2 } }
    { \pgfpointxy
        { \sseq@xmax + \sseq@xmaxpadding - 0.01 + \sseq@xoffset + \sseq@xgridstep/2 }
        { \sseq@ymax + \sseq@ymaxpadding - 0.01 + \sseq@yoffset + \sseq@ygridstep/2 } }
    \pgfusepath{stroke}
    \endpgfscope
    \egroup
}
\def\sseq@grid@go{
    \bgroup
    \pgfscope
    \sseq@useclip
    \pgfsetcolor{\sseq@gridcolor}
    \pgfsetlinewidth{\the\sseq@gridstrokethickness}
    \sseq@grid@setstepandgridstep
%
    % We don't want the grid to end with an extra line, so extend it by one step distance or
    % \sseq@---gridpadding, whichever is shorter.
    \sseq@grid@atmostgridstep\sseq@xminpadding{x}{\sseq@leftgridpadding}{1}
    \sseq@grid@atmostgridstep\sseq@xmaxpadding{x}{\sseq@rightgridpadding}{1}
    \sseq@grid@atmostgridstep\sseq@yminpadding{y}{\sseq@bottomgridpadding}{1}
    \sseq@grid@atmostgridstep\sseq@ymaxpadding{y}{\sseq@topgridpadding}{1}
%
    \pgfpathgrid[stepx=\pgf@xb,stepy=\pgf@yb]
    { \pgfpointxy
        { \sseq@xmin - \sseq@xminpadding + 0.01 + \sseq@xoffset }
        { \sseq@ymin - \sseq@yminpadding + 0.01 + \sseq@yoffset } }
    { \pgfpointxy
        { \sseq@xmax + \sseq@xmaxpadding - 0.01 + \sseq@xoffset }
        { \sseq@ymax + \sseq@ymaxpadding - 0.01 + \sseq@yoffset }
    }
    \pgfusepath{stroke}
    \endpgfscope
    \egroup
}
\def\sseq@grid@none{}
\def\sseq@grid@dots{
    \bgroup
    \pgfscope
    \pgfgettransform\sseq@savetransform
    \pgfgettransformentries{\sseq@a}{\sseq@b}{\sseq@c}{\sseq@d}{\sseq@u}{\sseq@v}
    \pgfsettransform\sseq@savetransform
    \sseq@useclip
    \pgftransformshift{\pgfqpoint{-1.5cm}{-0.5cm}}
    \pgfsetdash{{1pt}{\sseq@a*1cm-1pt}}{0.5cm+.5pt}
    \pgfsetlinewidth{1pt}
    \sseq@tempy=\sseq@ymin\relax
    \advance\sseq@tempy\m@ne
    \loop
    \advance\sseq@tempy\@ne
    \pgfpathmoveto{\pgfpointxy{\sseq@xmin + 0.5/\sseq@a}{\the\sseq@tempy}}
    \pgfpathlineto{\pgfpointxy{\sseq@xmax + 1.01 }{\the\sseq@tempy}}
    \ifnum\sseq@tempy<\sseq@ymax\repeat
    %\pgfpathgrid[stepx=1cm,stepy=1cm]{\pgfpoint{-0.5cm}{-0.5cm}}{\pgfpoint{\xmax cm-0.5cm}{\ymax cm-0.5cm}}
    \pgfusepath{stroke}
    \endpgfscope
    \egroup
}
%%%
%%% Draw Classes
%%%
%%% Class offsets
\sseqnewclasspattern{standard}{
    (0,0);
    (-0.13,0)(0.13,0);
    (-0.2,0)(0,0)(0.2,0);
    (-0.13,-0.13)(0.13,-0.13)(-0.13,0.13)(0.13,0.13);
    (-0.16,-0.16)(0.16,-0.16)(-0.16,0.16)(0.16,0.16)(0,0);
    (-0.13,-0.2)(-0.13,0)(-0.13,0.2)(0.13,-0.2)(0.13,0)(0.13,0.2);
}

\sseqnewclasspattern{linear}{
    (0,0);
    (-0.13,0)(0.13,0);
    (-0.2,0)(0,0)(0.2,0);
    (-0.3,0)(-0.1,0)(0.1,0)(0.3,0);
    (-0.4,0)(-0.2,0)(0,0)(0.2,0)(0.4,0);
    (-0.5,0)(-0.3,0)(-0.1,0)(0.1,0)(0.3,0)(0.5,0);
}
\def\sseq@offset#1#2{
    \sseq@eval{\@nx\pgftransformshift{
        \@nx\pgfqpointxy
            { \csname sseq@\sseq@classpattern xoffset#1/#2\endcsname }
            { \csname sseq@\sseq@classpattern yoffset#1/#2\endcsname }
    }}
}
\def\sseq@class@getparts#1(#2,#3,#4)[#5].{
    \sseq@seterrorannotation@drawing{#1}{#2}{#3}{#4}{#5}
    \def\sseq@thisclassname{class.(#2,#3,#4)}
    \def\sseq@thisnodename{sseq{#2,#3,#4}}
    \def\sseq@thispos{(#2,#3)}
    \edef\sseq@thisposnum{\sseq@obj{class.(#2,#3,#4).n}}
    \def\sseq@thisclassnum{#5}
    \sseq@tempx=#2\relax
    \sseq@tempy=#3\relax
}

\def\sseq@tooltip@wrapper#1#2{%
    \edef\temp{\detokenize\@xpthree{#2}}%
    \edef\temp{\@xp\sseqtooltip@replaceslashes\@xp{\temp}}%
    \sseq@eval{\@nx\pdftooltip{\unexpanded{#1}}{\temp}}%
}
\bgroup\lccode`\!=`\\\lowercase{\egroup
\def\sseqtooltip@replaceslashes#1{\sseqtooltip@replaceslashes@#1!\sseq@nil}
\def\sseqtooltip@replaceslashes@#1!#2{%
    #1%
    \ifx\sseq@nil#2\@xp\@gobble\else
        \@nx\@nx\@nx\textbackslash
        \@xp\sseqtooltip@replaceslashes@
    \fi#2%
}
}

% #1 -- the name of the node object
% Someday I should document this horrible mess of code here
\newif\ifsseq@permanentcycle
\newcount\sseq@totalclassesdrawn
\AtEndDocument{\message{Total classes: \the\sseq@totalclassesdrawn}}
\def\sseq@class@drawnode#1{%
    \global\advance\sseq@totalclassesdrawn\@ne
    \begingroup
    \sseq@class@getparts#1.
    \sseq@needstikzfalse
    \sseq@options@firstpassmode
        \sseq@thesseqstyle
        \sseq@theclassstyle
        \ifnum\sseq@obj{#1.page}=\sseq@infinitycount
            \sseq@thepermanentcyclestyle
        \else
            \sseq@thetransientcyclestyle
            \ifsseq@thispage
                \sseq@thethispagecyclestyle
            \fi
        \fi
        \the\sseq@scope@toks
        \sseq@obj{#1.needstikz}
%
    \sseq@outofrangetrue\relax % Mysterious that we need this \relax here...
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
        \sseq@outofrangefalse
        \pgfscope
        \let\tikz@options\pgfutil@empty
        \let\tikz@alias=\pgfutil@empty
        \def\pgfkeysdefaultpath{/sseqpages/class/}
        \sseq@options@secondpassmode
            \sseq@thesseqstyle
            \sseq@theclassstyle
            \ifnum\sseq@obj{#1.page}=\sseq@infinitycount
                \sseq@permanentcycletrue % This is to communicate with family style code...
                \sseq@thepermanentcyclestyle
            \else
                \sseq@permanentcyclefalse
                \sseq@thetransientcyclestyle
                \ifsseq@thispage
                    \sseq@thethispagecyclestyle
                \fi
            \fi
            \def\sseq@collections@featuretype{class}
            \the\sseq@scope@toks
            \sseq@obj{#1.options}
        \pgftransformshift{\pgfqpointxy{\numexpr\sseq@tempx +\sseq@xoffset-\sseq@x\relax}{\numexpr\sseq@tempy + \sseq@yoffset-\sseq@y\relax}}
        \iftikz@fullytransformed\pgfgettransform{\savetransform}\fi
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \sseq@obj@ifdef{#1.offset}{\sseq@obj{#1.offset}}{%
            \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}%
        }%
        \iftikz@fullytransformed\pgfsettransform{\savetransform}\else\pgftransformresetnontranslations\ifsseq@rotatelabels\sseq@globalrotatetransform\fi\fi
        \tikz@options
        % the value of \sseq@class@showname comes from styles. If there was a local option with showname, it's stored in #1.showname.
        % local value takes priority.
        \let\sseq@classlabelnodes\pgfutil@empty
        \edef\sseq@classnodetextoptions{\sseq@obj@ifdef{#1.nodetext.options}{\@xptwo\@nx\sseq@obj{#1.nodetext.options}}{}}
        \edef\sseq@classnodetext{\sseq@obj@ifdef{#1.nodetext}{\@xptwo\@nx\sseq@obj{#1.nodetext}}{}}
        \sseq@obj@ifdef{#1.showname}{\sseq@lettoobj\sseq@class@showname{#1.showname}}{}
        \ifcsname sseq@class@showname\endcsname
            \sseq@obj@ifdef{#1.name}{
	            \sseq@eval{\@nx\sseq@handleclassquotes@inner{\sseq@obj{#1.name}}{\sseq@class@showname}}
	       }{}
        \fi
        \ifsseq@needstikz
            \let\sseq@mode\tikz@mode
            \tikzset{every text node part/.code/.expand once={\sseq@globalrotatetransform\sseq@classnodetextoptions{}}}%
            \sseq@eval{%
                \@nx\node[/utils/exec={\let\@nx\tikz@mode\@nx\sseq@mode},
                    /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote
                ] (\sseq@thisnodename) {\unexpanded\@xp{\sseq@classnodetext}}
                [every text node part/.code={}];
            }%
        \else
            \tikz@node@textfont
            \sseq@setnodetext{\sseq@classnodetext}{\sseq@classnodetextoptions}
            \let\tikz@fig@name\sseq@thisnodename
            \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}%
            \tikz@alias
        \fi
        \sseq@obj{#1.labelnodes}
        \sseq@classlabelnodes % classlabelnodes comes from show name
        \sseq@obj@ifdef{#1.tooltip}{
            \pgfpointanchor{\sseq@thisnodename}{west}
            \pgf@xa=\pgf@x
            \pgfpointanchor{\sseq@thisnodename}{south}
            \pgf@ya=\pgf@y
%
            \pgf@process{\pgfpointdiff{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{west}}}{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{east}}}}
            \pgf@xb=\pgf@x
            \pgf@process{\pgfpointdiff{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{south}}}{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{north}}}}
            \pgf@yb=\pgf@y
%
            \setbox\tikz@tempbox=\hbox{
                \pgfinterruptpicture
                \sseqtooltip{\rule{\pgf@xb}{0pt}\rule{0pt}{\pgf@yb}}{\sseq@obj{#1.tooltip}}
                \endpgfinterruptpicture
            }
            {%
                \pgftransformshift{\pgfqpoint{\pgf@xa}{\pgf@ya}}%
                \pgfapproximatenonlineartransformation%
                \pgfqboxsynced{\tikz@tempbox}%
            }%
        }{}
        \endpgfscope
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfqpointxy{\numexpr\sseq@tempx+\sseq@xoffset-\sseq@x\relax}{\numexpr\sseq@tempy+\sseq@yoffset-\sseq@y\relax}}}%
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}
        \pgfcoordinate{\sseq@thisnodename}{\pgfpointorigin}%
    \fi
    \endgroup
}

% #1 -- label text
% #2 -- options
\def\sseq@setnodetext#1#2{%
    \setbox\pgfnodeparttextbox=\hbox{%
        \pgfscope%
        #2
        \tikzset{every text node part/.try}%
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
        \pgfinterruptpicture
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          #1%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
          \endpgfinterruptpicture
      \endpgfscope%
    }%
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}
\def\sseq@drawnode{%
  \pgfutil@tempdima=\pgflinewidth%
  {%
    \tikz@mode%
    %\iftikz@mode@clip \sseq@error@internal{Clip shouldn't happen here, but this error should be caught earlier}{}\fi %
    \iftikz@mode@draw%
        \iftikz@mode@double%
        % Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    % Step 10: Do stroke/fill as needed
    %
    \sseq@eval{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}%
    %
    % Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}

%%% Labels

% #1 -- label text
% #2 -- options
\def\sseq@drawlabel#1#2{
    \bgroup\pgfscope
    \def\tikz@mode{}
    \let\sseq@tikz@transform@save\tikz@transform
    \pgfkeyssetvalue{/pgf/inner xsep}{2pt}
    \pgfkeyssetvalue{/pgf/inner ysep}{2pt}
    \def\tikz@shape{rectangle}
    \let\tikz@transform\empty % The next line was set up to fix the classlabelstyle glitch
    \sseq@options@secondpassmode
    \sseq@thesseqstyle\sseq@thelabelstyle\sseq@theclasslabelstyle#2
    \tikz@options
    \pgftransformreset
    \pgftransformshift{\tikz@node@at}
    \tikz@lib@pos@call
    \tikz@transform
    \tikz@mode
    \let\tikz@transform\sseq@tikz@transform@save
    \sseq@setnodetext{\sseq@labeltextfn{#1}}{}
    \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{label}{\sseq@drawnode}%
    \ifsseq@pin
        \def\sseq@pinoptions{}
        \let\tikz@options\empty
        \let\tikz@mode\empty
        \sseq@thepinstyle
        #2
        \sseq@pinoptions
        \tikz@options
        \tikz@mode
        \sseq@drawedge@findsourcetarget{\tikz@fig@name}{}{label}{}
        \pgfpathmoveto{\sseq@sourcecoord}%
        \pgfpathlineto{\sseq@targetcoord}%
        \sseq@eval{\noexpand\pgfusepath{%
            draw
            \iftikz@mode@fill fill,\fi
            \iftikz@mode@draw draw,\fi
        }}%
    \fi
    \endpgfscope\egroup
}


%%%
%%% Drawing edges
%%%
\def\sseq@ifinrange(#1){\sseq@ifinrange@#1,\sseq@nil}
\def\sseq@ifinrange@#1,#2,#3\sseq@nil{%
    \sseq@tempx=#1\relax\sseq@tempy=#2\relax
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
    \sseq@outofrangefalse
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \@xp\pgfutil@secondoftwo
    \else
        \@xp\pgfutil@firstoftwo
    \fi
}

% #1 -- source node
% #2 -- source anchor
% #3 -- target node
% #4 -- target anchor
% Calculate actual start and end of the edge (node borders), return the results stored in \sseq@sourcecoord, \sseq@targetcoord
\def\sseq@drawedge@findsourcetarget#1#2#3#4{
    \edef\sseq@edgesourceanchor{#2}
    \edef\sseq@edgetargetanchor{#4}
    \let\tempaf\pgfutil@empty
    \ifx\sseq@edgesourceanchor\pgfutil@empty % Check that the source doesn't have a specified anchor
        \def\tempa{\pgfpointanchor{#1}{center}}% if so, start by taking the center of that coordinate
    \else
        \edef\tempa{\@nx\pgfpointanchor{#1}{\sseq@edgesourceanchor}} % If it has an anchor, use that
        \let\tempaf\tempa
    \fi
    \ifx\sseq@edgetargetanchor\pgfutil@empty % check that the target doesn't have a specified anchor
        \def\tempb{\pgfpointshapeborder{#3}{\tempa}}% if so, our end point is the point on the boundary of node b that is in the direction of our initial start coordinate
    \else
        \edef\tempb{\@nx\pgfpointanchor{#3}{\sseq@edgetargetanchor}}% If it has a specified anchor, use that
    \fi
    \let\tempbf\tempb
    \ifx\tempaf\pgfutil@empty%
        \def\tempaf{\pgfpointshapeborder{#1}{\tempb}}%
    \fi
    \let\sseq@sourcecoord\tempaf
    \let\sseq@targetcoord\tempbf
}

\def\sseq@fullcoord@to@partialcoord(#1){\sseq@fullcoord@to@partialcoord@#1,\@nil}
\def\sseq@fullcoord@to@partialcoord@#1,#2,#3\@nil{{#1cm}{#2cm}}
% #1 -- source (full)
% #2 -- target (full)
% #3 -- which type of edge (either "structline" or "differential")
% #4 -- options
\def\sseq@drawedge(#1)(#2)#3#4{%
    \begingroup\pgfscope
    % If either class is part of a family we aren't drawing, don't draw the edge either.
    \expandafter\ifx\csname pgf@sh@pi@sseq{#1}\endcsname\pgfpictureid\else
        \@xp\sseq@break
    \fi
    \expandafter\ifx\csname pgf@sh@pi@sseq{#2}\endcsname\pgfpictureid\else
        \@xp\sseq@break
    \fi
    \def\sseq@edgetype{#3}
    \let\sseq@collections@featuretype\sseq@edgetype
    \let\sseq@edgesourceanchor\pgfutil@empty
    \let\sseq@edgetargetanchor\pgfutil@empty
%
    \sseq@needstikzfalse
    \def\pgfkeysdefaultpath{/sseqpages/#3/}%
    \sseq@options@bothpassmode
    \sseq@thesseqstyle
    \sseq@theedgestyle\csname sseq@the#3style\endcsname\the\sseq@scope@toks
    #4%
    \csname sseq@collections@#3@hook\endcsname
    \pgftransformshift{\pgfqpointxy{-\the\sseq@x}{-\the\sseq@y}}%
    % puts results into \sseq@sourcecoord and \sseq@targetcoord
    \sseq@drawedge@findsourcetarget{sseq{#1}}{\sseq@edgesourceanchor}{sseq{#2}}{\sseq@edgetargetanchor}
%
    \tikz@options
    \tikz@mode
    \def\temparrowstartspec{}%
    \def\temparrowendspec{}%
    \pgfcoordinate{tempa}{\sseq@sourcecoord}%
    \pgfcoordinate{tempb}{\sseq@targetcoord}%
    \pgftransformreset
    \sseq@outofrangefalse
    \sseq@ifinrange(#1){}{
        \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@#3@spec\endcsname}}
        \sseq@outofrangetrue
    }%
    \sseq@ifinrange(#2){}{
        \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}
        \sseq@outofrangetrue
    }
    \ifsseq@outofrange
        \sseq@handleoffpageedge{#1}{#2}%
    \fi
    \ifsseq@drawedge
        % TODO: should some sort of transformation manipulation be here? Maybe allow user to specify preference?
        % Don't draw dots on very short segments
        \pgfpointdiff{\sseq@targetcoord}{\sseq@sourcecoord}
        \pgfmathveclen{\pgf@x}{\pgf@y}%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \ifnum\pgfmathresult<10\relax%%17? % TODO: Fix this predicate
            \tikzset{every text node part/.append code={\pgfsetcolor{white}}}% I wonder why this is here...
            \ifx\temparrowstartspec\pgfutil@empty
            \else
                \def\temparrowstartspec{\pgfsetarrowsstart{}}%
            \fi
            \ifx\temparrowendspec\pgfutil@empty
            \else
                \def\temparrowendspec{\pgfsetarrowsend{}}%
            \fi
        \fi
        \ifsseq@needstikz
            \draw[/sseqpages,
                /utils/exec={\sseq@thesseqstyle\sseq@theedgestyle\csname sseq@the#3style\endcsname\the\sseq@scope@toks
                             \temparrowstartspec\temparrowendspec #4}%
            ]  (tempa) to (tempb);%
        \else
            \temparrowstartspec
            \temparrowendspec
            \pgfpathmoveto{\pgfpointanchor{tempa}{center}}%
            \pgfpathlineto{\pgfpointanchor{tempb}{center}}%
            \sseq@eval{\noexpand\pgfusepath{%
                \iftikz@mode@fill fill,\fi
                \iftikz@mode@draw draw,\fi
            }}%
        \fi
    \fi
    \sseq@breakpoint
    \endpgfscope\endgroup
}

% TODO: this macro is super expensive. Make it faster
\def\sseq@handleoffpageedge#1#2{
    \pgfpathmoveto{\sseq@sourcecoord}%
    \pgfpathlineto{\sseq@targetcoord}%
    \pgfgetpath\thispath
    \pgfusepath{discard}%
    \pgfintersectionsortbysecondpath
    \pgfintersectionofpaths{\pgfsetpath\sseq@theclippath}{\pgfsetpath\thispath}%
    \ifcase\pgfintersectionsolutions\relax
        % No intersections, but one or both endpoints may be out of range but still in clipping region due to scaling. Add ellipses as appropriate.
        \sseq@ifinrange(#1){% If the first endpoint is in range, the second must be out of range b/c sseq@outofrange is true.
            %\edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}
        }{%
            \sseq@ifinrange(#2){}{\sseq@drawedge@handletrickyedge}% uh-oh, both ends are out of range
        }%
    \or
        \sseq@ifinrange(#1){% If the startpoint is in range, the intersection must be the end.
            \def\sseq@targetcoord{\pgfpointintersectionsolution{1}}
            \pgfcoordinate{tempb}{\sseq@targetcoord}
        }{%
            \sseq@ifinrange(#2){% If the startpoint is out of range and the endpoint is in range, the intersection must be the start
                \def\sseq@sourcecoord{\pgfpointintersectionsolution{1}}%
                \pgfcoordinate{tempa}{\sseq@sourcecoord}%
            }{\sseq@drawedge@handletrickyedge}% Uh-oh, both ends are out of range.
        }
    \or% an orphan
        \ifsseq@draworphanedges
            \sseq@drawedge@handleorphan
        \else
            \sseq@drawedgefalse % Don't draw "orphaned edges"
        \fi
    \else
        \sseq@error{clip-not-convex}%
        \sseq@breakfifi
    \fi
}

\def\sseq@drawedge@handletrickyedge{%
    \ifsseq@draworphanedges        
        \pgfintersectionsortbysecondpath
        \pgfintersectionofpaths{\pgfsetpath\sseq@therangepath}{\pgfsetpath\thispath}%
        \ifnum\pgfintersectionsolutions=\z@
            \sseq@drawedgefalse % don't draw orphan edges that never intersect actual range
        \else% Now we have to make a line through tempa and tempb long enough so that it intersects the original clip area twice.
            \pgfmathanglebetweenpoints{\pgfpointanchor{tempa}{center}}{\pgfpointanchor{tempb}{center}}%
            \edef\tempangle{\pgfmathresult}
            \pgfpathmoveto{\pgfpointadd{\pgfpointanchor{tempa}{center}}{\pgfpointpolar{\tempangle}{100cm}}}% a really long line
            \pgfpathlineto{\pgfpointadd{\pgfpointanchor{tempa}{center}}{\pgfpointpolar{\tempangle}{-100cm}}}%
            \pgfgetpath\thispath
            \pgfusepath{discard}
            \pgfintersectionofpaths{\pgfsetpath\sseq@theclippath}{\pgfsetpath\thispath}
            \sseq@drawedge@handleorphan
        \fi
    \else
        \sseq@drawedgefalse
    \fi
}


\def\sseq@drawedge@handleorphan{%
    \def\sseq@sourcecoord{\pgfpointintersectionsolution{2}}%
    \def\sseq@targetcoord{\pgfpointintersectionsolution{1}}%
    \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@\sseq@edgetype @spec\endcsname}}%
    \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@\sseq@edgetype @spec\endcsname}}%
    \pgfcoordinate{tempa}{\sseq@sourcecoord}%
    \pgfcoordinate{tempb}{\sseq@targetcoord}%
}


% #1 -- uid
% #2 -- first coordinate
% #3 -- second coordinate
\def\sseq@circleclass@draw#1#2#3{
    \begingroup
        % If either class is part of a family we aren't drawing, don't draw the fit either.
        \expandafter\ifx\csname pgf@sh@pi@sseq{#2}\endcsname\pgfpictureid\else
            \@xp\sseq@break
        \fi
        \expandafter\ifx\csname pgf@sh@pi@sseq{#3}\endcsname\pgfpictureid\else
            \@xp\sseq@break
        \fi
        \pgfmathanglebetweenpoints{\pgfpointanchor{sseq{#2}}{center}}{\pgfpointanchor{sseq{#3}}{center}}
        \let\tempangle\pgfmathresult
        \let\tikz@lib@fit@scan@handle\sseq@fit@tikz@lib@fit@scan@handle % install fit modifications.
        \let\tikz@calc@anchor\sseq@fit@tikz@calc@anchor
        \sseq@tempiftrue
        \sseq@options@secondpassmode
        \node[
            rotate fit=\tempangle,
            /utils/exec={\sseq@thesseqstyle\sseq@thecircleclassstyle\the\sseq@scope@toks\sseq@savedoptioncode
                \sseq@obj{#1.options}
                \sseq@obj{#1.fitnodes}
                \@xp\pgfkeysalso\@xp{\romannumeral0\sseq@obj{#1.tikzprimoptions}}
            }
        ] {};
        \sseq@breakpoint
    \endgroup
}
% Modifies tikz commands \tikz@lib@fit@scan@handle from \pgf\frontendlayer\tikz\libraries\tikzlibraryfit.code.tex line 81 and
% \tikz@calc@anchor from \pgf\frontendlayer\tikz\tikz.code.tex line 5164
% make it so that fit silently ignores nodes that are not defined.
% This is copied with modification from \pgf\frontendlayer\tikz\libraries\tikzlibraryfit.code.tex line 81
\def\sseq@fit@tikz@lib@fit@scan@handle#1{%
  \ifsseq@tempif % this has been set in the following macro to be true if there is a node with the given name. If it's not true, ignore this.
      \iftikz@shapeborder%
        % Ok, fit all four external anchors, if they exist
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{west}}%
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{east}}%
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{north}}%
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{south}}%
      \else%
        \tikz@lib@fit@adjust{#1}%
      \fi%
  \fi
  \sseq@tempiftrue
  \tikz@lib@fit@scan%
}

% This is copied with modification from \pgf\frontendlayer\tikz\tikz.code.tex line 5164
\def\sseq@fit@tikz@calc@anchor#1.#2\tikz@stop{%
  \pgfutil@ifundefined{pgf@sh@ns@#1}{\sseq@tempiffalse}{%If the node doesn't exist, don't throw an error but record that we should skip it
    \pgfpointanchor{\tikz@pp@name{#1}}{#2}%
  }%s
}


%%
%% Patch tikz coords
%%

\def\sseq@patchtikzcoords{
    \let\sseq@tikz@scan@one@point@noshift\sseq@tikz@scan@one@point@noshift@active
    \tikzoption{shift}{\sseq@tikzshift{##1}}
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\tikz@to@curve@path\sseq@tikz@to@curve@path
    \let\tikz@@@to@compute@relative\sseq@tikz@@@to@compute@relative

    \let\tikz@grid\sseq@tikz@grid
    \let\tikz@scan@handle@options\sseq@tikz@scan@handle@options
    \let\tikz@@@parse@polar\sseq@tikz@@@parse@polar
}

% Some of the stuff in tikzlibrarycalc will probably be broken, hopefully not too much
\let\sseq@tikz@scan@one@point@noshift\tikz@scan@one@point
\let\sseq@tikz@@@parse@regular@save\tikz@@@parse@regular

\def\sseq@tikz@scan@one@point@noshift@active#1{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@save
    \def\sseq@scanonepoint@cmd{\let\tikz@@@parse@regular\sseq@tikz@@@parse@regular#1}
    \tikz@scan@one@point\sseq@scanonepoint@cmd%
}

% Probably there are more places that shouldn't have shifts inserted.
\def\sseq@tikzshift#1{\tikz@addtransform{\sseq@tikz@scan@one@point@noshift\pgftransformshift#1\relax}}


\def\sseq@tikz@to@curve@path{%
  [every curve to]
  \pgfextra{
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@save % I added this to prevent repeated offsets from screwing us up
    %\let\sseq@tikz@scan@one@point@noshift\tikz@scan@one@point
    \iftikz@to@relative\tikz@to@compute@relative\else\tikz@to@compute\fi
  }
  \tikz@computed@path
  \tikztonodes%
}

\let\sseq@tikz@@@to@compute@relative\tikz@@@to@compute@relative


\patchcmd\sseq@tikz@@@to@compute@relative{%
    \let\tikz@second@point=\tikz@toto
}{%
    \pgf@process{\pgfpointadd{\tikz@toto}{\pgfqpointxy{\sseq@xoffset}{\sseq@yoffset}}}%
    \edef\tikz@toto{\@nx\pgfpoint{\the\pgf@x}{\the\pgf@y}}%
    \let\tikz@second@point=\tikz@toto
}{}{\error}




% \tikz@parse@splitxyz: we should set up an error to make this unreachable?
\let\sseq@tikz@grid\tikz@grid % line 3158
\let\sseq@tikz@scan@handle@options\tikz@scan@handle@options % 4959
\let\sseq@tikz@@@parse@polar\tikz@@@parse@polar % 5063

\def\sseq@tikz@@@parse@regular#1#2#3){%
  \pgfutil@in@,{#3}%
  \ifpgfutil@in@%
    \tikz@parse@splitxyz{#1}{#2}#3,%
  \else%
    \tikz@checkunit{#2}%
    \iftikz@isdimension%
      \tikz@checkunit{#3}%
      \iftikz@isdimension%
        \def\@next{#1{\pgfpointxy{(#2)/1cm+\sseq@xoffset}{(#3)/1cm+\sseq@yoffset}}}%
      \else%
        \def\@next{#1{\pgfpointxy{(#2)/1cm+\sseq@xoffset}{#3+\sseq@yoffset}}}%
      \fi%
    \else%
      \tikz@checkunit{#3}%
      \iftikz@isdimension%
        \def\@next{#1{\pgfpointxy{#2+\sseq@xoffset}{(#3)/1cm+\sseq@yoffset}}}%
      \else%
        \def\@next{#1{\pgfpointxy{#2+\sseq@xoffset}{#3+\sseq@yoffset}}}%
      \fi%
    \fi%
  \fi%
  \@next%
}




%% New shapes and arrows
%% These use lots of keys with spaces so it's convenient to turn off ExplSyntax.

% Stolen from: https://tex.stackexchange.com/a/24621
\pgfqkeys{/pgf}{
    ellipse ratio/.code={\pgfkeyssetvalue{/pgf/ellipse ratio}{#1}},
    ellipse ratio/.initial=1
}
\pgfdeclareshape{newellipse}
{
  \inheritsavedanchors[from=ellipse]
  \inheritanchorborder[from=ellipse]
  \savedanchor\radius{%
    %
    % Caculate ``height radius''
    %
    \pgf@y=.5\ht\pgfnodeparttextbox%
    \advance\pgf@y by.5\dp\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by\pgf@yb%
    %
    % Caculate ``width radius''
    %
    \pgf@x=.5\wd\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@xb{\pgfkeysvalueof{/pgf/inner xsep}}%
    \advance\pgf@x by\pgf@xb%
    %
    % Adjust
    %
    \pgfkeysgetvalue{/pgf/ellipse ratio}{\ratioscale}
    \pgfmathsetmacro\widthfactor{sqrt(\ratioscale^2+1)/\ratioscale}
    \pgfmathsetmacro\heightfactor{sqrt(\ratioscale^2+1)}
    \pgf@x=\widthfactor\pgf@x%
    \pgf@y=\heightfactor\pgf@y%
    %
    % Adjust height, if necessary
    %
    \pgfmathsetlength\pgf@yc{\pgfkeysvalueof{/pgf/minimum height}}%
    \ifdim\pgf@y<.5\pgf@yc%
      \pgf@y=.5\pgf@yc%
    \fi%
    %
    % Adjust width, if necessary
    %
    \pgfmathsetlength\pgf@xc{\pgfkeysvalueof{/pgf/minimum width}}%
    \ifdim\pgf@x<.5\pgf@xc%
      \pgf@x=.5\pgf@xc%
    \fi%
    %
    % Add outer sep
    %
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \advance\pgf@x by\pgf@xb%
    \advance\pgf@y by\pgf@yb%
  }

  \inheritanchor[from=ellipse]{center}
  \inheritanchor[from=ellipse]{mid}
  \inheritanchor[from=ellipse]{base}
  \inheritanchor[from=ellipse]{north}
  \inheritanchor[from=ellipse]{south}
  \inheritanchor[from=ellipse]{west}
  \inheritanchor[from=ellipse]{mid west}
  \inheritanchor[from=ellipse]{base west}
  \inheritanchor[from=ellipse]{north west}
  \inheritanchor[from=ellipse]{south west}
  \inheritanchor[from=ellipse]{east}
  \inheritanchor[from=ellipse]{mid east}
  \inheritanchor[from=ellipse]{base east}
  \inheritanchor[from=ellipse]{north east}
  \inheritanchor[from=ellipse]{south east}

  \inheritbackgroundpath[from=ellipse]
}

%%
%%
%% n concentric circles
%%

\tikzset{circlen/.code={\def\circlen@n{#1}\pgfkeysalso{shape=circlen@shape}}}
\pgfdeclareshape{circlen@shape}
{
  \savedanchor\centerpoint{%
    \pgf@x=.5\wd\pgfnodeparttextbox%
    \pgf@y=.5\ht\pgfnodeparttextbox%
    \advance\pgf@y by-.5\dp\pgfnodeparttextbox%
  }

  \saveddimen\radius{%
    %
    % Caculate ``height radius''
    %
    \pgf@ya=.5\ht\pgfnodeparttextbox%
    \advance\pgf@ya by.5\dp\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@ya by\pgf@yb%
    %
    % Caculate ``width radius''
    %
    \pgf@xa=.5\wd\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@xb{\pgfkeysvalueof{/pgf/inner xsep}}%
    \advance\pgf@xa by\pgf@xb%
    %
    % Calculate length of radius vector:
    %
    \pgf@process{\pgfpointnormalised{\pgfqpoint{\pgf@xa}{\pgf@ya}}}%
    \ifdim\pgf@x>\pgf@y%
        \c@pgf@counta=\pgf@x%
        \ifnum\c@pgf@counta=\z@%
        \else%
          \divide\c@pgf@counta by 255\relax%
          \pgf@xa=16\pgf@xa\relax%
          \divide\pgf@xa by\c@pgf@counta%
          \pgf@xa=16\pgf@xa\relax%
        \fi%
      \else%
        \c@pgf@counta=\pgf@y%
        \ifnum\c@pgf@counta=\z@%
        \else%
          \divide\c@pgf@counta by 255\relax%
          \pgf@ya=16\pgf@ya\relax%
          \divide\pgf@ya by\c@pgf@counta%
          \pgf@xa=16\pgf@ya\relax%
        \fi%
    \fi%
    \pgf@x=\pgf@xa%
    %
    % If necessary, adjust radius so that the size requirements are
    % met:
    %
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/minimum width}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/minimum height}}%
    \ifdim\pgf@x<.5\pgf@xb%
        \pgf@x=.5\pgf@xb%
    \fi%
    \ifdim\pgf@x<.5\pgf@yb%
        \pgf@x=.5\pgf@yb%
    \fi%
    %
    % Now, add larger of outer sepearations.
    %
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgf@x by\pgf@yb%
    \else%
      \advance\pgf@x by\pgf@xb%
    \fi%
    \pgf@xb=2pt
    \multiply\pgf@xb\circlen@n
    \advance\pgf@x\pgf@xb
    \advance\pgf@x-2pt\relax
  }

  %
  % Anchors
  %
  \anchor{center}{\centerpoint}
  \anchor{mid}{\centerpoint\pgfmathsetlength\pgf@y{.5ex}}
  \anchor{base}{\centerpoint\pgf@y=0pt}
  \anchor{north}{\centerpoint\advance\pgf@y by\radius}
  \anchor{south}{\centerpoint\advance\pgf@y by-\radius}
  \anchor{west}{\centerpoint\advance\pgf@x by-\radius}
  \anchor{east}{\centerpoint\advance\pgf@x by\radius}
  \anchor{mid west}{\centerpoint\advance\pgf@x by-\radius\pgfmathsetlength\pgf@y{.5ex}}
  \anchor{mid east}{\centerpoint\advance\pgf@x by\radius\pgfmathsetlength\pgf@y{.5ex}}
  \anchor{base west}{\centerpoint\advance\pgf@x by-\radius\pgf@y=0pt}
  \anchor{base east}{\centerpoint\advance\pgf@x by\radius\pgf@y=0pt}
  \anchor{north west}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by-0.707107\pgf@xa
    \advance\pgf@y by0.707107\pgf@xa
  }
  \anchor{south west}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by-0.707107\pgf@xa
    \advance\pgf@y by-0.707107\pgf@xa
  }
  \anchor{north east}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by0.707107\pgf@xa
    \advance\pgf@y by0.707107\pgf@xa
  }
  \anchor{south east}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by0.707107\pgf@xa
    \advance\pgf@y by-0.707107\pgf@xa
  }
  \anchorborder{
    \pgf@xa=\pgf@x%
    \pgf@ya=\pgf@y%
    \edef\pgf@marshal{%
      \noexpand\pgfpointborderellipse
      {\noexpand\pgfqpoint{\the\pgf@xa}{\the\pgf@ya}}
      {\noexpand\pgfqpoint{\radius}{\radius}}%
    }%
    \pgf@marshal%
    \pgf@xa=\pgf@x%
    \pgf@ya=\pgf@y%
    \centerpoint%
    \advance\pgf@x by\pgf@xa%
    \advance\pgf@y by\pgf@ya%
  }

  %
  % Background path
  %
  \behindbackgroundpath{
    \pgfutil@tempdima=\radius%
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgfutil@tempdima by-\pgf@yb%
    \else%
      \advance\pgfutil@tempdima by-\pgf@xb%
    \fi%
    \sseq@tempcount=\@ne
    \loop
    \pgfpathcircle{\centerpoint}{\pgfutil@tempdima}%
    \advance\pgfutil@tempdima-2pt\relax
    \advance\sseq@tempcount\@ne
    \ifnum\sseq@tempcount<\circlen@n \repeat
    \tikz@mode
    \sseq@eval{\noexpand\pgfusepath{
        \iftikz@mode@draw draw,\fi
    }}
  }
  \backgroundpath{%
    \pgfutil@tempdima=\radius%
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgfutil@tempdima by-\pgf@yb%
    \else%
      \advance\pgfutil@tempdima by-\pgf@xb%
    \fi%
    \advance\pgfutil@tempdima2pt\relax
    \pgfutil@tempdimb=-2pt\relax
    \multiply\pgfutil@tempdimb\circlen@n
    \advance\pgfutil@tempdima\pgfutil@tempdimb\relax
    \pgfpathcircle{\centerpoint}{\pgfutil@tempdima}
  }
}



% For out of bounds edges:

\pgfdeclarearrow{
    name = ...,
    parameters = { \the\pgfarrowlength\the\pgflinewidth},
    setup code = {
        % The different end values:
        \pgfarrowssetlineend{-\pgfarrowlength}
        \pgfarrowssetbackend{-0.6\pgfarrowlength}
        % The hull
        \pgfarrowshullpoint{-\pgfarrowlength}{0pt}
        \pgfarrowshullpoint{\pgfarrowlength}{0pt}
        % Saves: Only the length:
        \pgfarrowssavethe\pgfarrowlength
        \pgfarrowssavethe\pgflinewidth
    },
    drawing code = {
        \pgfpathcircle{\pgfpoint{-0.7\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.4\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.1\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathclose
        \pgfusepathqfill
    },
    defaults = { length = 0.3cm }
}

